# 01-리팩터링: 첫 번째 예시

## 1.1 시작

다양한 연극을 외주로 받아서 공연하는 극단이 있다고 생각해보자.

* 공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정한다.
* 현재 이 극단은 두 가지 장르, 즉 비극과 희극만 공연한다.
* 그리고 공연료와 별개로 포인트를 지급해 다음 번 의뢰 시 공연료를 할인받을 수도 있다.

극단은 공연할 연극 정보를 다음과 같이 간단한 JSON 파일에 저장한다.

{% code title="plays.json" %}
```javascript
{
  "hamlet": { "name": "Hamlet", "type": "tragedy" },
  "as-like": { "name": "As You Like It", "type": "comedy" },
  "othello": { "name": "Othello", "type": "tragedy" }
}
```
{% endcode %}

공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.

{% code title="invoices.json" %}
```javascript
[
  {
    "customer": "BigCo",
    "performances": [
      {
        "playID": "hamlet",
        "audience": 55
      },
      {
        "playID": "as-like",
        "audience": 35
      },
      {
        "playID": "othello",
        "audience": 40
      }
    ]
  }
]
```
{% endcode %}

공연료 청구서를 출력하는 코드는 다음과 같이 간단히 함수로 구현한다.

```javascript
const invoicesJson = require('./invoices.json')
const playsJson = require('./plays.json')

function statement(invoice, plays) {
  let totalAmount = 0;
  let volumeCredits = 0;
  let result = `청구 내역 (고객명: ${invoice[0].customer})\n`;

  const format = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
  }).format;

  for (const perf of invoice[0].performances) {
    const play = plays[perf.playID];
    let thisAmount = 0;

    switch (play.type) {
      case 'tragedy':
        thisAmount = 40000;
        if (perf.audience > 30) {
          thisAmount += 1000 * (perf.audience - 30);
        }
        break;
      case 'comedy':
        thisAmount = 30000;
        if (perf.audience > 20) {
          thisAmount += 10000 + 500 * (perf.audience - 20);
        }
        thisAmount += 300 * perf.audience;
        break;
      default:
        throw new Error(`알 수 없는 장르: ${play.type}`);
    }

    // 포인트 적립
    volumeCredits += Math.max(perf.audience - 30, 0);
    // 희극 관객 5명마다 추가 포인트 제공
    if (play.type === 'comedy') volumeCredits += Math.floor(perf.audience / 5);

    // 청구 내역 출력
    result += ` ${play.name}: ${format(thisAmount / 100)} (${
      perf.audience
    }석)\n`;
    totalAmount += thisAmount;
  }
  result += `총액: ${format(totalAmount / 100)}\n`;
  result += `적립 포인트: ${volumeCredits}점\n`;
  return result;
}
```

이 코드에 앞의 두 JSON 파일을 입력해 실행한 결과는 다음과 같다.

```
청구 내역 (고객명: BigCo)
 Hamlet: $650.00 (55석)
 As You Like It: $580.00 (35석)
 Othello: $500.00 (40석)
총액: $1,730.00
적립 포인트: 47점
```

## 1.2 예시 프로그램을 본 소감

* 작동은 하지만 이런 코드가 수백 줄짜리 프로그램의 일부라면 간단한 인라인 함수 하나라도 이해하기 쉽지 않다.
* 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, <mark style="color:purple;">먼저 기능을 추가하기 쉬운 형태로 리팩터링</mark>하고 나서 원하는 기능을 추가한다.
* 사용자 입장을 생각할 때 청구 내역을 HTML 형태로 출력하는 기능이 추가로 필요한데, 리팩터링 전 현재 코드의 경우 이 변경이 어느 부분에 영향을 줄지 생각해보자.
  * 우선 태그를 삽입해야 하니 청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야 한다. 이렇게 되면 statement() 함수의 복잡도가 크게 증가한다.
  * 장르 추가 시 공연료와 적립 포인트 계산법에 영향을 줘, 연극 장르와 공연료 정책이 달라질 때마다 statement() 함수를 수정해야&#x20;

## 1.3 리팩터링의 첫 단계

* <mark style="color:purple;">리팩터링하기 전 제대로 된 테스트부터 마련. 테스트는 반드시 자가진단하도록 만든다.</mark>
  * statement() 함수는 문자열을 반환하므로, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해준다.
  * 이후 statement()가 반환한 문자열과 준비해둔 정답 문자열을 비교한다.

## 1.4 statement() 함수 쪼개기
